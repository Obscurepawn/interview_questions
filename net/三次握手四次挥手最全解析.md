
# 三次握手四次挥手解析

<font color="Orange" size="5px">**目录**</font>

<!-- vscode-markdown-toc -->
* 1. [三次握手基本流程](#)
* 2. [三次握手通俗描述](#-1)
* 3. [问题1-三次握手中如果某次握手信息对方没有收到会怎么样？](#1-)
* 4. [问题2-**【重点】为什么要进行三次握手？两次握手可以吗？**](#2-)
* 5. [问题3-第2次握手令ACK=1，为什么还要令SYN=1](#3-2ACK1SYN1)
* 6. [总结：**三次握手需要掌握的程度**](#-1)
* 7. [四次挥手基本流程](#-1)
* 8. [四次挥手的通俗理解](#-1)
* 9. [问题1-为什么需要四次挥手](#1--1)
* 10. [问题2-CLOSE-WAIT和TIME-WAIT阶段的意义](#2-CLOSE-WAITTIME-WAIT)
* 11. [总结：**四次挥手需要掌握的程度**](#-1)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name=''></a>三次握手基本流程

<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src="image/TCP.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1.TCP三次握手过程</div>
</center>

在图1可以看到一些譬如SYN=1,ACK=1的描述，这种英文字母全为大写的描述是**标识位**，以下是tcp协议的标志位的含义

```
URG：紧急指针（urgent pointer）有效。

ACK：确认序号有效。（为了与确认号Ack区分开，我们用大写表示）

PSH：接收方应该尽快将这个报文交给应用层。

RST：重置连接。

SYN：发起一个新连接。

FIN：释放一个连接。
```

**重点关注ACK，RST，SYN，FIN即可**。在三次握手中只需要关注ACK和SYN即可。

-----

<font color="Orange">**两个确认号的含义(重点，这里好好看一下)**</font>

Seq：随机序列号。**如果对方之前发送过Ack确认号的话，则为上一次接收到的Ack的值**

Ack：确认号。其值为上一次接收到的的Seq的值再+1，表示准确收到了上一个Seq的值，**也期望对方下一次给我发的数据包中的Seq确认号为这个值，这样可以确保对方收到了我的Ack包**。

----

逐步解释三次握手的每一步在做什么

```
在这里需要记住的是每一步进行的操作，标识位的值和确认号的值。 并且client和server的状态变化。
```

三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：

**这里的结束CLOSE阶段是指每一个不工作的端口号都是CLOSE状态，开始LISTEN进行端口监听的时候就结束了CLOSE状态**

① 首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：
```
标志位为 SYN，表示请求建立连接；
序号为 Seq = x（x 一般取随机数）；
随后客户端进入 SYN-SENT 阶段。
```
② 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：
```
标志位为 SYN 和 ACK，ACK表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，SYN表示同意创建新连接；
序号为 Seq = y；
确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。
```
③ 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：

```
标志位为 ACK，表示确认收到服务器端同意连接的信号；
序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；
确认号为 Ack= y + 1，表示收到服务器端序号 Seq，并将其值加 1 作为自己的确认号 Ack 的值。
随后客户端进入 ESTABLISHED。
当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。
```
##  2. <a name='-1'></a>三次握手通俗描述

如果你不太懂每一步为什么要这样做，可以联系到现实生活中的视频通话，道理是一样的。每一步都是为了**让对方知道自己已经收到了对方的数据包**,

```
男方M：宝贝，你听得到吗？（发起请求，SYN=1，Seq=x）
女方F：宝贝，我听到了。（确认请求，ACK=1，Ack=x+1）你听得到吗？（发起请求，SYN=1,Seq=y）
男方M：宝贝，我听到了。（回复请求，ACK=1,Seq=x+1,Ack=y+1）
通话矫正完毕，开始通话。。。
男方M：宝贝，今天我满脑子想的都是你^_^。（传输数据）
女方F：哎呀~~✿◡‿◡（接收数据）。今天想我什么了呀~（传输数据）
男方M：....
女方F：....
```

##  3. <a name='1-'></a>问题1-三次握手中如果某次握手信息对方没有收到会怎么样？

这一点简单看看就行，大概了解一下，大概率不会考

下文提到的accept是套接字编程的一个函数，记住就行，不需要深究去钻"系统调用"是什么这种牛角尖

- 若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的函数会返回-1。
- 若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。
- 若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accept() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。**因此服务器端接收到来自客户端发送来的数据时会发送<font color="red">RST报文</font>给客户端，消除客户端单方面建立连接的状态。**

##  4. <a name='2-'></a>问题2-**【重点】为什么要进行三次握手？两次握手可以吗？**

三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。**若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。**

我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，**而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。**

**并且三次握手可以可靠地确保双方已经交换了初始序号**

##  5. <a name='3-2ACK1SYN1'></a>问题3-第2次握手令ACK=1，为什么还要令SYN=1

此处第二次握手中的SYN=1表示的是服务器端同意建议连接。

##  6. <a name='-1'></a>总结：**三次握手需要掌握的程度**

1. 问题1～3必须理解清楚，这部分不需要死记硬背要理解清楚
2. 三次握手的过程图要能够自己画一次，要清晰地知道每一个标志位，确认号，序号的作用以及client和server各自的状态的变化。

**三次握手中涉及的状态变化：**
- client：Close -> SYN-SENT -> Established(这个阶段指已建立连接的状态)
- server：Close -> SYN-RECV -> Established(同上)



##  7. <a name='-1'></a>四次挥手基本流程

 <center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src="image/CLOSE_TCP.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.TCP四次挥手过程</div>
</center>


四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：

① 首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接，其中：
```
标记位为 FIN，表示请求释放连接；
序号为 Seq = u；
随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。
```
② 服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，其中：
```
标记位为 ACK，表示接收到客户端释放连接的请求；
序号为 Seq = v；
确认号为 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值；
随后服务器开始准备释放服务器端到客户端方向上的连接。
客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶段。
```
③ 服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文，其中：
```
标记位为 FIN 和 ACK，表示已经准备好释放连接了；
序号为 Seq = w；
确认号 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。
随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。
```
④ 客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中：
```
标记位为 ACK，表示接收到服务器准备好释放连接的信号；
序号为 Seq= u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；
确认号为 Ack= w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。
随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。
```

名词解释：
1. **MSL：最长报文段寿命，任何报文段在网络中可以存在的最长时间**

##  8. <a name='-1'></a>四次挥手的通俗理解
```
男方M：宝贝，我要去洗澡睡觉了ヾ(•ω•`)o。（断开请求，FIN=1,Seq=u）
女方F：好的，宝贝。（确认请求，ACK=1,Ack=u+1,Seq=v）
女方F：明天也要想我呀(*￣3￣)╭。（传输最后数据）
女方F：我也要去洗澡了。（断开请求，FIN=1，确认对方请求，ACK=1,Ack=u+1,Seq=w）
男方F：mua~（确认请求，ACK=1,Ack=w+1,Seq=u+1）
```


##  9. <a name='1--1'></a>问题1-为什么需要四次挥手

释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次挥手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。

##  10. <a name='2-CLOSE-WAITTIME-WAIT'></a>问题2-CLOSE-WAIT和TIME-WAIT阶段的意义

- 在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。

- TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态。若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。除此之外，假设客户端最后一次发送的 ACK 包在传输的时候丢失了，由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用<font color="red">**RST包**</font>来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。

```
PS: 这里TIME-WAIT状态存在的原因提到了两点
1. 为了防止立即建立相同的连接时接收到上一次连接的数据。这一点可能会让你比较费解，哪里来的上一次连接的数据。其实就是CLOSE-WAIT阶段的数据包在发送时可能发生网络延迟，导致这些包迟到了，到了的时候已经是下一次连接了。所以在短时间内立刻建立相同端口的tcp连接是有可能收到上一次的数据的。所以要使用一个TIME-WAIT阶段等待2MSL的时间消化掉这些迟到的数据包，当TIME-WAIT阶段收到迟到的数据包时将不做任何回复。
2. 防止最后一次Ack包服务器端没有收到导致超时重发FIN包时得到RST包，此时服务器会认为出现了异常错误情况，但其实只是网络延迟的正常情况。
```


##  11. <a name='-1'></a>总结：**四次挥手需要掌握的程度**

1. 问题1～2必须理解清楚，这部分不需要死记硬背要理解清楚
2. 四次挥手的过程图要能够自己画一次，要清晰地知道每一个标志位，确认号，序号的作用以及client和server各自的状态的变化。

**四次握手中涉及的状态变化：**
- client：Established -> FIN-WAIT-1 -> FIN-WAIT-2 -> Close
- server：Established -> CLOSE-WAIT -> LAST-ACK -> Close
